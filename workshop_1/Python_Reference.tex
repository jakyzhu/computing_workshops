\documentclass{article}
\usepackage{enumerate, amsmath ,amsfonts}
\usepackage[margin=1in]{geometry} %change page margins
\usepackage{listings}
\usepackage[english]{SASnRdisplay} %codeblocks in SAS and R. English option gives English captions (otherwise they'll be in Danish)
\usepackage{hyperref} %embed hyperlinks in the pdf
\usepackage{times}

\title{Introduction to Python\\
	\Large{Biostatistics Computing Workshop}}
\author{Adam Peterson \\ \small{University of Michigan Department of Biostatistics}}
\date{18 November 2015}

\begin{document}
	\lstset{language=Python}
	\maketitle
	
	This handout, and other reference material can be found online at \href{https://github.com/apeterson91/computing_workshops}{github}

	\section{Data Structures}
			\begin{enumerate}
				\item lists
					\subitem ordered array
					\subitem Main data structure for Queues,Stacks,etc.
					\subitem zero indexed
			\end{enumerate}
	\begin{lstlisting}
	>>list_1 = [1,2,3,4,5,"pineapple"] ## six value array
	>>list_1[0] == 1 ## accesses first element of list, 
	### checks to see if it is the same as 1
	### evaluates to True
	>>len(list_1) == 5 ## evaluates to True
	>>list_2 = list() ## empty list
	>>list_2.append(1) ## will place the element 1 into the
	0th position of the list
	\end{lstlisting}
			\begin{enumerate}
				\item sets
					\subitem unordered collection
					\subitem Removes Duplicates
					\subitem same operatiosn as "Math" sets
			\end{enumerate}
	\begin{lstlisting}
	>>set_1 = {1,2,3,"cats"}
	>>print(set_1) 
	  "cats" 1 ,3 ,2  ## notice the lack of order
	>> set_2 = {"dogs","canaries","cats"}
	>> new_set = set_1.union(set_2)
	>> print(new_set)
	3, 2, 1, "cats", "canaries", "dogs"
	>> print(set_1.intersection(set_2))
	"cats"
	\end{lstlisting}
			\begin{enumerate}
				\item dictionaries (dicts)
					\subitem associative arrays
					\subitem Great for simulating one-to-one/onto functions (small cases)
			\end{enumerate}
	\begin{lstlisting}
	>>my_first_dict = {"John":"Appleseed","Banana":"Pie"}
	>>print(my_first_dict["John"])
	  "Appleseed"
	\end{lstlisting}
	\section{Control Flow, Variable Declaration}
		All the things you do \textit{with} your data, once you've declared them in memory\\
		\subsection{boolean operators}
			\begin{table}[h]
				\centering
				\begin{tabular}{c|c}
					\textbf{Python Operator} & \textbf{Result} \\ \hline
					\verb| &,and| & Boolean 'And" operator \\
					      or  & Boolean 'Or' operator \\ 
					\verb|= | & Assignment operator  \\
					\verb|==| & Equality Operator \\ 
					\verb| != | & Not equal \\
					\verb| %  | & Modulus Operator \\
				\end{tabular}
			\end{table}
		\subsection{keywords}
		\begin{enumerate}
			\item if statement
		\end{enumerate}
		\begin{lstlisting}
		foo = True ## For all below - INDENTATION MATTER!!!
		if foo: ## Interpreter will assume you mean "if foo==true"
			print "HelloWorld"
		>> "HelloWorld"
		if not foo:
			print "Goodbyeworld"
		elif foo == 7: ## chained if statements
			print "ElloGuvner"
		else:
			print "HelloWorld"
		>> "HelloWorld"
		\end{lstlisting}
		\begin{enumerate}
			\item while statement
		\end{enumerate}
		\begin{lstlisting}
		index_var = 0
		while index_var < 3:
			print index_var
			index_var +=1 ## increment index_var
		>> "0"
		   "1"
		   "2"
		\end{lstlisting}
		\begin{enumerate}
			\item def function
		\end{enumerate}
		\begin{lstlisting}
		def my_first_function(parameter_argument_1):
			"""
			This is a doc string that explains 
			this functions purpose in the world
			this function tells the user
			whether the function is even or odd
			"""
			if type(parameter_argument_1) != int:
				return "Pleaseonlyenterintarguments"
			if parameter_argument_1 % 2 == 0:
				return "Even"
			else:
				return "Odd"
		\end{lstlisting}
		
	\section{The Zen of Python}
	 Beautiful is better than ugly. \\
	 Explicit is better than implicit. \\
	 Simple is better than complex.\\
	 Complex is better than complicated. \\
	 Flat is better than nested.\\
	 Sparse is better than dense.\\
	 Readability counts.\\
	 Special cases aren't special enough to break the rules.\\
	 Although practicality beats purity.\\
	 Errors should never pass silently.\\
	 Unless explicitly silenced.\\
	 In the face of ambiguity, refuse the temptation to guess.\\
	 There should be one-- and preferably only one --obvious way to do it.\\
	 Although that way may not be obvious at first unless you're Dutch.\\
	 Now is better than never.\\
	 Although never is often better than *right* now.\\
	 If the implementation is hard to explain, it's a bad idea.\\
	 If the implementation is easy to explain, it may be a good idea.\\
	 Namespaces are one honking great idea -- let's do more of those!	\\	
	\section{Reference Materials}
	\begin{enumerate}
		\item Classes
			\subitem \href{www.coursera.org}{Coursera}
			\subsubitem \href{www.coursera.org/specializations/python}{Python for Everybody Specialization}
			\subsubitem \href{www.coursera.org/specializations/fundamentalscomputing2}{Fundamentals of Computing Specialization}
		\item Problem Sets
			\subitem \href{www.codeacademy.com}{Codeacademy}
			\subitem \href{www.hackerrank.com}{hackerrank}
			\subitem \href{rosalind.info/problems/locations}{Rosalind BioInformatics Problems}
			\subitem \href{www.projecteuler.net}{Project Euler}
		\item Packages/Software Worth Knowing
			\subitem \href{www.scipy-lectures.org}{Scipy Lectures}
			\subitem \href{ipython-books.github.io/cookbook}{Introduction to Ipython}
			\subitem \href{pandas.pydata.org}{Pandas}
			\subitem \href{statsmodels.sourceforge.net}{Statsmodels}
			\subitem \href{scikit-learn.org/stable}{scikit-learn}
	\end{enumerate}
	
\end{document}